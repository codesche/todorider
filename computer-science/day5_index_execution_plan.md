# Day 5 — 데이터베이스: 인덱스와 실행계획

## 1. 핵심 요약

- **인덱스(Index)**
  - DB 검색 속도 향상을 위한 자료구조 (대부분 B+Tree 사용)
  - 장점: 빠른 검색, 정렬, 범위 조회 성능 향상
  - 단점: 쓰기 성능 저하(INSERT/UPDATE/DELETE 시 인덱스도 갱신 필요), 저장 공간 차지

- **인덱스 유형**
  - Primary Index: 기본 키 기반 인덱스
  - Secondary Index: 보조 인덱스
  - Unique Index: 중복 불가 보장
  - Composite Index: 다중 컬럼 인덱스 (선행열 규칙 중요)

- **인덱스 설계 시 고려사항**
  - 조회 조건에 맞게 컬럼 순서 고려 (선행열 규칙)
  - 카디널리티 높은 컬럼을 앞에 배치
  - 너무 많은 인덱스는 오히려 성능 저하

- **실행 계획 (Execution Plan)**
  - SQL 실행 경로를 시각화한 정보
  - 주요 항목:
    - **Access Type**: 풀 스캔, 인덱스 스캔, 범위 스캔 등
    - **Possible Keys**: 사용 가능한 인덱스
    - **Key**: 실제 사용된 인덱스
    - **Rows**: 처리 예상 행 수
    - **Extra**: 추가 정보 (Using index, Using where 등)

- **커버링 인덱스 (Covering Index)**
  - 인덱스만으로 쿼리 결과를 반환 가능 (테이블 액세스 불필요)
  - 성능 최적화에 유용

---

## 2. 면접형 Q&A 예시

**Q1. 인덱스를 쓰면 무조건 성능이 좋아지나요?**  
👉 아닙니다. 인덱스는 조회 성능을 높이지만, 쓰기 연산에서는 성능 저하가 발생할 수 있습니다. 따라서 조회와 쓰기 패턴을 고려하여 설계해야 합니다.

**Q2. Composite Index에서 선행열 규칙이란 무엇인가요?**  
👉 복합 인덱스의 왼쪽부터 사용해야 효율적으로 작동한다는 원칙입니다. 예를 들어 (col1, col2) 인덱스가 있다면 col1만 사용하는 쿼리에는 적용되지만, col2만 사용하는 경우는 적용되지 않습니다.

**Q3. 실행 계획에서 Rows 항목은 무엇을 의미하나요?**  
👉 쿼리 실행 시 DB가 예상하는 행의 개수입니다. Rows 값이 크면 성능 저하 가능성이 있습니다.

**Q4. 커버링 인덱스란 무엇인가요?**  
👉 쿼리에 필요한 모든 컬럼이 인덱스에 포함되어 있어 테이블을 읽을 필요가 없는 경우를 의미합니다.

---

## 3. 오늘의 미션
- [ ] 블로그에 `DB-01: 인덱스와 실행계획` 포스트 작성
- [ ] GitHub `cs-notes/db/index-execution-plan.md` 업로드
- [ ] 직접 답변: “Composite Index 설계 시 고려사항은?”
